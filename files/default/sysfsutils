#! /bin/sh -e

### BEGIN INIT INFO
# Provides:          sysfsconf
# Required-Start:    mountkernfs
# Should-Start:      udev module-init-tools cpufrequtils
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:
# Short-Description: Set sysfs variables from /etc/sysfs.conf
# Description:       Similarly to /etc/init.d/procps.sh, you can configure
#                    values for sysfs variables (such as power management
#                    defaults) and /sys file permissions in /etc/sysfs.conf.
### END INIT INFO

# /etc/init.d/sysfsutils:
#
# (c) 2005 Martin Pitt <mpitt@debian.org>

CONFFILE=/etc/sysfs.conf
CONFDIR=/etc/sysfs.d

[ -r "$CONFFILE" -o -d "$CONFDIR" ] || exit 0

# RHEL does not have the init-functions file, so lets copy what we need
#. /lib/lsb/init-functions
log_begin_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    echo -n "$@"
}

log_failure_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@ "..."
    fi
    log_end_msg 1 || true
}

log_end_msg_pre () { :; }
log_end_msg_post () { :; }

log_use_fancy_output () {
    TPUT=/usr/bin/tput
    EXPR=/usr/bin/expr
    if [ -t 1 ] && [ "x${TERM:-}" != "x" ] && [ "x${TERM:-}" != "xdumb" ] && [ -x $TPUT ] && [ -x $EXPR ] && $TPUT hpa 60 >/dev/null 2>&1 && $TPUT setaf 1 >/dev/null 2>&1; then
        [ -z $FANCYTTY ] && FANCYTTY=1 || true
    else
        FANCYTTY=0
    fi
    case "$FANCYTTY" in
        1|Y|yes|true)   true;;
        *)              false;;
    esac
}

# int log_end_message (int exitstatus)
log_end_msg () {
    # If no arguments were passed, return
    if [ -z "${1:-}" ]; then
        return 1
    fi

    retval=$1

    log_end_msg_pre "$@"

    # Only do the fancy stuff if we have an appropriate terminal
    # and if /usr is already mounted
    if log_use_fancy_output; then
        RED=`$TPUT setaf 1`
        YELLOW=`$TPUT setaf 3`
        NORMAL=`$TPUT op`
    else
        RED=''
        YELLOW=''
        NORMAL=''
    fi

    if [ $1 -eq 0 ]; then
        echo "."
    elif [ $1 -eq 255 ]; then
        /bin/echo -e " ${YELLOW}(warning).${NORMAL}"
    else
        /bin/echo -e " ${RED}failed!${NORMAL}"
    fi
    log_end_msg_post "$@"
    return $retval
}

# End of copy

load_conffile() {
    FILE="$1"
    sed  's/#.*$//; /^[[:space:]]*$/d;
	  s/^[[:space:]]*\([^=[:space:]]*\)[[:space:]]*\([^=[:space:]]*\)[[:space:]]*=[[:space:]]*\(.*\)/\1 \2 \3/' \
	  $FILE | {
	while read f1 f2 f3; do
	    if [ "$f1" = "mode" -a -n "$f2" -a -n "$f3" ]; then
		if [ -f "/sys/$f2" ] || [ -d "/sys/$f2" ]; then
		    chmod "$f3" "/sys/$f2"
		else
		    log_failure_msg "unknown attribute $f2"
		fi
	    elif [ "$f1" = "owner" -a -n "$f2" -a -n "$f3" ]; then
		if [ -f "/sys/$f2" ]; then
		    chown "$f3" "/sys/$f2"
		else
		    log_failure_msg "unknown attribute $f2"
		fi
	    elif [ "$f1" -a -n "$f2" -a -z "$f3" ]; then
		if [ -f "/sys/$f1" ]; then
		    # Some fields need a terminating newline, others
		    # need the terminating newline to be absent :-(
		     echo -n "$f2" > "/sys/$f1" 2>/dev/null ||
			echo "$f2" > "/sys/$f1"
		else
		    log_failure_msg "unknown attribute $f1"
		fi
	    else
		log_failure_msg "syntax error in $CONFFILE: '$f1' '$f2' '$f3'"
		log_end_msg 1
		exit 1
	    fi
	done
    }
}

case "$1" in
    start|restart|force-reload)
	log_begin_msg "Setting sysfs variables..."

	for file in $CONFFILE $CONFDIR/*.conf; do
	    [ -r "$file" ] || continue
	    load_conffile "$file"
	done

	log_end_msg 0
	;;
    stop)
	;;
    *)
	echo "Usage: /etc/init.d/sysfsutils {start|stop|force-reload|restart}"
	exit 1
	;;
esac
